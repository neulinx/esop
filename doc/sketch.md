# 随时更新文档条目

## 激活活动属性的函数形式。

``
-spec activate(key(), state()) -> {pid, pid(), state()} |
                                  {data, term(), state()} |
                                  {error, term()}.
``

## 扁平化的权衡。

如果把内部和外部链接统一放置在首层，作为活动属性，即为扁平设计。如果把外部链接置于 links 属性中作为二级属性，则属于层次结构。纯粹从美学角度，我比较倾向于扁平设计。

## 函数与进程的权衡。

侧重函数式编程语言的话，活动属性采用函数较好；侧重Actor Model编程的话，活动属性采用进程比较好。综合考虑，决定使用进程，用异步松耦合调用模式。

## 一致性与简化设计。

活动属性、外部链接、内部链接统一起来。由本actor创建的进程就认为是本地链接，否则认为是外部链接。统一采用 {link, Monitor, Pid}格式。

## _links有三种数据类型，pid，函数和map。

- map中的数据有三种类型：
  - map。自带状态数据，生成本地连接。
  - {ref, 内部属性名，ID}，返回pid或者data。
  - ID，默认从 '_registry'中获取pid或者map。

返回map数据时，需要在本地创建进程，被称为本地连接；返回pid时，认为是外部连接。内部链接用link监测，外部链接用monitor监测。

## 状态数据规则：

  - 存储在数据库中的原始数据采用JSON格式。
    - 属性名称只能是 binary 类型（字符型）。
    - 用于系统的属性名以‘\_’为前缀。
  - 运行时数据采用map类型。
    - 运行时产生的新属性名称采用atom类型，作为内部应用的都要以‘_’作为前缀。
  - 休眠时的状态数据与运行时数据基本相同。只是pid类型全部都要摘除。
    - 支持休眠的actor需要自行维护关联Pid的休眠处理。通常可以触发级联的休眠动作。

## 数据转换：
  
  - 与原始数据之间通过自定义规则转换后，再通过第三方JSON编解码模块进行转换。
  - 转运行时数据时，数值不能出现 atom 和 tuple 类型。
  - 转原始数据时，默认只转换名称是binary类型的属性，且数值类型不得为：
    - atom
    - tuple
    - pid
    - function

## 数据类型：

- 活动属性：被封装成进程的属性。
- {link, reference() | local, pid()}
- map()
- \_links：属性的初始数据。设计中是把所有属性都视为link的，只是这里存放的是只读的初始值。也许命名为links是不太合适。
      - map with actions。
      - {ref, Key, ID}, Key可以是Pid或者属性名，从指定的进程或者actor活动属性中获取数据。
      - Data，非活动属性的初始值。
      
## 寻址方式。

  - 值为普通的数据的属性，直接通过map的函数进行访问。
  - 活动属性是按需加载的。每个数据访问都可能触发一次活动属性进程的创建。
    - 活动属性包含状态数据，则直接加载这个状态。
    - 活动属性key不在当前actor中，再在links中找。
    - 在links中找不到的，再看state的boundary是否为opened。如果是，则从'_registry'中获取数据。
